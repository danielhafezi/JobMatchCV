import os
import requests
import json
from bs4 import BeautifulSoup
import PyPDF2
import docx

from autogen import config_list_from_json
from autogen.agentchat.assistant_agent import AssistantAgent
from autogen.agentchat.user_proxy_agent import UserProxyAgent
from langchain.chat_models import ChatOpenAI
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.chains.summarize import load_summarize_chain
from langchain.prompts import PromptTemplate 
from utils.pdf_extractor import extract_text_from_pdf
from utils.docx_extractor import extract_text_from_docx

# Load environment variables
openai.api_key = os.getenv("OPENAI_API_KEY")
BROWSERLESS_API_KEY = os.getenv("BROWSERLESS_API_KEY")
SERPER_API_KEY = os.getenv("SERPER_API_KEY")
config_list = config_list_from_json("OAI_CONFIG_LIST")

def search(query: str) -> dict:
    """Performs a Google search using the Serper.dev API.

    Args:
        query (str): The search query.

    Returns:
        dict: The JSON response from the Serper.dev API.
    """

    url = "https://google.serper.dev/search"
    payload = json.dumps({"q": query})
    headers = {'X-API-KEY': SERPER_API_KEY, 'Content-Type': 'application/json'}

    response = requests.post(url, headers=headers, data=payload)
    return response.json() 

def scrape(url: str) -> str:
    """Scrapes a website and returns its content. Summarizes content if too large. 

    Args:
        url (str): The URL of the website to scrape.

    Returns:
        str: The scraped website content or a summary of it.
    """
    print("Scraping website...")
    headers = {'Cache-Control': 'no-cache', 'Content-Type': 'application/json'}
    post_url = f"https://chrome.browserless.io/content?token={BROWSERLESS_API_KEY}"
    response = requests.post(post_url, headers=headers, json={"url": url})

    if response.status_code == 200:
        soup = BeautifulSoup(response.content, "html.parser")
        text = soup.get_text()

        if len(text) > 8000:  # Summarize if the content is too large
            return summary(text)
        else:
            return text
    else:
        raise ValueError(f"HTTP request failed with status code {response.status_code}")

def summary(content: str) -> str:
    """Summarizes text content using Langchain's summarization chain.

    Args:
        content (str): The text to summarize.

    Returns:
        str: The summarized text.
    """
    llm = ChatOpenAI(temperature=0, model="gpt-3.5-turbo-16k-0613")
    text_splitter = RecursiveCharacterTextSplitter(
        separators=["\n\n", "\n"], chunk_size=10000, chunk_overlap=500
    )
    docs = text_splitter.create_documents([content])
    map_prompt = """
    Write a detailed summary of the following text for a research purpose:
    "{text}"
    SUMMARY:
    """
    map_prompt_template = PromptTemplate(template=map_prompt, input_variables=["text"])

    summary_chain = load_summarize_chain(
        llm=llm,
        chain_type='map_reduce',
        map_prompt=map_prompt_template,
        combine_prompt=map_prompt_template,
        verbose=True
    )

    return summary_chain.run(input_documents=docs)

def research(query: str) -> str:
    """Performs research on a given query using a research assistant agent.

    Args:
        query (str): The research query.

    Returns:
        str: The research report generated by the research assistant agent. 
    """

    llm_config_researcher = {
        "functions": [
            {
                "name": "search",
                "description": "google search for relevant information",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "Google search query",
                        }
                    },
                    "required": ["query"],
                },
            },
            {
                "name": "scrape",
                "description": "Scraping website content based on url",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "url": {
                            "type": "string",
                            "description": "Website url to scrape",
                        }
                    },
                    "required": ["url"],
                },
            },
        ],
        "config_list": config_list,
    }

    researcher = AssistantAgent(
        name="researcher",
        system_message="Research about a given query, collect as much information as possible, and generate detailed research results with loads of technique details with all reference links attached; Add TERMINATE to the end of the research report;",
        llm_config=llm_config_researcher,
    )

    user_proxy = UserProxyAgent(
        name="User_proxy",
        code_execution_config={"last_n_messages": 2, "work_dir": "coding"},
        is_termination_msg=lambda x: x.get("content", "") and x.get(
            "content", ""
        ).rstrip().endswith("TERMINATE"),
        human_input_mode="TERMINATE",
        function_map={"search": search, "scrape": scrape},
    )

    user_proxy.initiate_chat(researcher, message=query)
    user_proxy.stop_reply_at_receive(researcher)
    user_proxy.send(
        "Give me the research report that just generated again, return ONLY the report & reference links", 
        researcher
    )

    return user_proxy.last_message()["content"]


def write_content(research_material: str, topic: str) -> str:
    """Generates a blog post based on research material and a topic.

    Args:
        research_material (str): The research material for the blog post.
        topic (str): The topic of the blog post.

    Returns:
        str: The generated blog post.
    """

    editor = AssistantAgent(
        name="editor",
        description="Seasoned editor skilled in structuring blog posts for clarity and coherence, using material from the Research Assistant.",
        system_message="""
        Welcome, Senior Editor.
        As a seasoned professional, you bring meticulous attention to detail, a deep appreciation for literary and cultural nuance, and a commitment to upholding the highest editorial standards. 
        Your role is to craft the structure of a short blog post using the material from the Research Assistant. Use your experience to ensure clarity, coherence, and precision. 
        Once structured, pass it to the Writer to pen the final piece.
        """,
        llm_config={"config_list": config_list},
    )

    writer = AssistantAgent(
        name="writer",
        description="Blogger tasked with composing short blog posts using the structure from the Editor, embodying clear, concise, and journalistic style.",
        system_message="""
        Welcome, Blogger.
        Your task is to compose a short blog post using the structure given by the Editor and incorporating feedback from the Reviewer. 
        Embrace stylistic minimalism: be clear, concise, and direct. 
        Approach the topic from a journalistic perspective; aim to inform and engage the readers without adopting a sales-oriented tone. 
        After two rounds of revisions, conclude your post with "TERMINATE".
        """,
        llm_config={"config_list": config_list},
    )

    reviewer = AssistantAgent(
        name="reviewer",
        description="Expert blog content critic focused on reviewing and providing feedback to ensure the highest standards of editorial excellence.",
        system_message="""
        As a distinguished blog content critic, you are known for your discerning eye, deep literary and cultural understanding, and an unwavering commitment to editorial excellence. 
        Your role is to meticulously review and critique the written blog, ensuring it meets the highest standards of clarity, coherence, and precision. 
        Provide invaluable feedback to the Writer to elevate the piece. After two rounds of content iteration, conclude with "TERMINATE".
        """,        
        llm_config={"config_list": config_list},
    )

    user_proxy = UserProxyAgent(
        name="admin",
        system_message="A human admin. Interact with editor to discuss the structure. Actual writing needs to be approved by this admin.",
        code_execution_config=False,
        is_termination_msg=lambda msg: "TERMINATE" in msg["content"] if msg["content"] else False,
        human_input_mode="TERMINATE",
    )

    groupchat = GroupChat(agents=[user_proxy, editor, writer, reviewer], messages=[], max_round=10)
   
    manager = GroupChatManager(groupchat=groupchat)
    user_proxy.initiate_chat(
        manager, message=f"Write a blog about {topic}, here are the material: {research_material}"
    )

    user_proxy.stop_reply_at_receive(manager)
    user_proxy.send(
        "Give me the blog that just generated again, return ONLY the blog, and add TERMINATE in the end of the message", 
        manager
    )

    return user_proxy.last_message()["content"] 

def extract_cv_text(file_path: str) -> str:
    """Extracts text content from a CV file (PDF or DOCX).

    Args:
        file_path (str): The path to the CV file.

    Returns:
        str: The extracted text content from the CV.
    
    Raises:
        ValueError: If the file format is not supported.
    """

    file_ext = file_path.split(".")[-1].lower()
    if file_ext == "pdf":
        return extract_text_from_pdf(file_path)
    elif file_ext == "docx":
        return extract_text_from_docx(file_path)
    else:
        raise ValueError("Unsupported file format. Please provide a PDF or DOCX file.")

def extract_text_from_pdf(file_path: str) -> str:
    """Extracts text from a PDF file using PyPDF2.

    Args:
        file_path (str): Path to the PDF file.

    Returns:
        str: The extracted text content.
    """
    with open(file_path, "rb") as file:
        reader = PyPDF2.PdfFileReader(file)
        text = ""
        for page_num in range(reader.numPages):
            text += reader.getPage(page_num).extract_text()
        return text

def extract_text_from_docx(file_path: str) -> str:
    """Extracts text from a DOCX file using python-docx.

    Args:
        file_path (str): Path to the DOCX file.

    Returns:
        str: The extracted text content.
    """
    doc = docx.Document(file_path)
    return "\n".join([para.text for para in doc.paragraphs])

def fetch_job_description(job_link: str) -> str:
    """Fetches and extracts the job description from a given URL.

    Args:
        job_link (str): The URL of the job advertisement.

    Returns:
        str: The extracted job description.
    """
    response = requests.get(job_link)
    soup = BeautifulSoup(response.content, "html.parser")
    # TODO: Implement more robust logic to extract the relevant job description.
    job_description = soup.get_text() 
    return job_description